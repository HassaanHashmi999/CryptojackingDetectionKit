
from __future__ import print_function
from pickle import TRUE
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from psutil import cpu_percent
import psutil
import os
import requests
from bs4 import BeautifulSoup
import time

from psutil._common import bytes2human
import socket
#STATIC Analysis

choose=input("\n\nDO you want to enter the URL Yourself[y/n]::")
if choose =='y':
    URL=input("Paste the Link Address::")
else:
    URL ='http://nu.edu.pk/'
r=requests.get(URL)
soup = BeautifulSoup(r.content,"html.parser") 

javatags=soup.find_all('script')

f = open("Java_Libs.txt", "w")
for links in javatags:
    linki=links.get('src')
    jav=str(linki)
    if jav[0]!="/":
        f.write(str(jav))
        f.write("\n")


print("\n\nTHE JAVA LIBRARIES HAVE BEEN STORED\n")
f.close()

print("NOW MONITERING THE PROCESSES RUNNING ON THE BROWSER\n")
print("WRITING THE BROWSER PROCESSES TO FILE\n")
print(' ')
z=open("B_PRoCESS.txt",'w')
time.sleep(2)
for proc in psutil.process_iter(['pid','cpu_percent','name']):
    if(proc.name()=='firefox' or proc.name()=='file:// Content'or proc.name()=='Web Content' or proc.name()=='Xorg'):
        bp1=str(proc.info)
        bp2="The CPU USAGE::"
        neti=proc.cpu_percent(interval=1)
        if neti>200:
            print(" \n\n\nThe Suspected process to Mine Crypto using your CPU is",proc.pid)
            print(" The Memory Usage of the Process is ",proc.memory_info())
            if(proc.name()=='firefox' or proc.name()=="chrome"):
                print("SOME MALICIOUS CODE IS RUNNING ON YOUR BROWSER")

            #print(" The Memory Usage of the Process is ",proc.connections(kind='inet'))
            time.sleep(10)
        bp3=str(neti)
        z.write(bp1+bp2+bp3)
        z.write("\n")
    else:
        print(proc.info)    
z.close()
frame_len=200
cpu_U=[]
cpu_T=[]
core_T=[]




print("\n\nNow MONITERING THE RESOURCES\n")
time.sleep(2)

fig=plt.figure(figsize=(6,2))
def animate(i):
    temps = psutil.sensors_temperatures()
    for name, entries in temps.items():
        for entry in entries:
            if(entry.label=="CPU"):
             cputemp=entry.current
            if(entry.label=="Core 0"):
             cor_t=entry.current
    cpu_U.append(cpu_percent())
    cpu_T.append(cputemp)
    core_T.append(cor_t)
    if len(cpu_U)<=frame_len and len(cpu_T)<=frame_len:
        plt.cla()
        plt.plot(cpu_U,'r',label="CPU USAGE IN PERCENT")
        plt.plot(cpu_T,'b',label="CPU Temp IN PERCENT")
        plt.plot(core_T,'g',label="Core Temp IN PERCENT")
    else:
        plt.cla()
        plt.plot(cpu_U[-frame_len],'r',label="CPU USAGE IN PERCENT")
        plt.plot(cpu_T[-frame_len],'b',label="CPU Temp IN PERCENT")
        plt.plot(core_T[-frame_len],'g',label="Core Temp IN PERCENT")
        
    plt.ylim(0,100)
    plt.xlabel("Time (s)")
    plt.ylabel("PERCENTAGE(%)")
    plt.legend(loc="upper right")
    plt.title("CPU UTILIZATION")
   
        
    plt.tight_layout()
    
ani=FuncAnimation(plt.gcf(),animate,interval=1000) 
plt.show()
if cpu_percent()>80:
    print("\n The USAGE OF THE CPU IS ABOVE 80 SOME OTHER USER MAY BE USING YOUR CPU TO MINE CRYPTO\n")
    time.sleep(2)
time.sleep(3)
print("\n\nNOW MONITERING THE Network!!\n")
time.sleep(2)



#MOnitering the Packets sent/Recieved
last_received=psutil.net_io_counters().packets_recv
last_sent=psutil.net_io_counters().packets_sent
last_total=last_received+last_sent
last_receivedB=psutil.net_io_counters().bytes_recv
last_sentB=psutil.net_io_counters().bytes_sent
last_totalB=last_receivedB+last_sentB
af_map = {
    socket.AF_INET: 'IPv4',
    socket.AF_INET6: 'IPv6',
    psutil.AF_LINK: 'MAC',
}

duplex_map = {
    psutil.NIC_DUPLEX_FULL: "full",
    psutil.NIC_DUPLEX_HALF: "half",
    psutil.NIC_DUPLEX_UNKNOWN: "?",
}



stats = psutil.net_if_stats()
io_counters = psutil.net_io_counters(pernic=True)
for nic, addrs in psutil.net_if_addrs().items():
    print("%s:" % (nic))
    if nic in stats:
        st = stats[nic]
        print("    stats          : ", end='')
        print("speed=%sMB, duplex=%s, mtu=%s, up=%s" % (
            st.speed, duplex_map[st.duplex], st.mtu,
            "yes" if st.isup else "no"))
    if nic in io_counters:
        io = io_counters[nic]
        print("    incoming       : ", end='')
        print("bytes=%s, pkts=%s, errs=%s, drops=%s" % (
            bytes2human(io.bytes_recv), io.packets_recv, io.errin,
            io.dropin))
        print("    outgoing       : ", end='')
        print("bytes=%s, pkts=%s, errs=%s, drops=%s" % (
            bytes2human(io.bytes_sent), io.packets_sent, io.errout,
            io.dropout))
    for addr in addrs:
        print("    %-4s" % af_map.get(addr.family, addr.family), end="")
        print(" address   : %s" % addr.address)
        if addr.broadcast:
            print("         broadcast : %s" % addr.broadcast)
        if addr.netmask:
            print("         netmask   : %s" % addr.netmask)
        if addr.ptp:
            print("      p2p       : %s" % addr.ptp)
    print("")
time.sleep(1)
check=0
chk=" "
time.sleep(3)
print("\n\nNOW MONITERING THE Network Packets\n")
while chk!="exit":
    packt_received=psutil.net_io_counters().packets_recv
    packt_sent=psutil.net_io_counters().packets_sent
    packt_total=packt_received+packt_sent
    packt_receivedB=psutil.net_io_counters().bytes_recv
    packt_sentB=psutil.net_io_counters().bytes_sent
    packt_totalB=packt_receivedB+packt_sentB


    new_RECEIVED=packt_received-last_received
    new_SENT=packt_sent-last_sent
    new_total=packt_total-last_total


    new_RECEIVEDB=packt_receivedB-last_receivedB
    new_SENTB=packt_sentB-last_sentB
    new_totalB=packt_totalB-last_totalB

    MB_R=new_RECEIVED
    MB_S=new_SENT
    MB_T=new_total
    MB_RB=new_RECEIVEDB/1024/1024
    MB_SB=new_SENTB/1024/1024
    MB_TB=new_totalB/1024/1024

    if check>1:
     print(" |",MB_R,"Packets recv  ",MB_S,"Packets sent",    MB_T,"Packets Total |")
     print(f" |{MB_RB:.2f},MB recv {MB_SB:.2f}MB sent {MB_TB:.2f}MBs Total |\n\n")

   
    if check==10:
        chk=input("Enter 'exit' to Terminate or 'cont' to Continue::")
        check=0

    check+=1
    last_received=packt_received
    last_sent=packt_sent
    last_total=packt_total
    last_receivedB=packt_receivedB
    last_sentB=packt_sentB
    last_totalB=packt_totalB
    time.sleep(1)
    
choose=input("\n\nDO you want to Moniter the Processes[y/n]::")
if choose =='y':
    os.system("top")
